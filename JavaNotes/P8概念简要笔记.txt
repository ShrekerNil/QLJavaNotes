P8概念简要笔记
====== JARVIS ======
- Reliable、Scalable、Distributed
- Distributed、Middleware
- Micro Service
- DevOps
- Service Mesh
- AIOps
- ChatOps
- Service Less

1、几个架构层面优化/调优的概念
  - Buffer：缓冲：主要是为了提高传输的效率。有10份数据，一份一份的存和把10份数据放在一个Buffer中存一次：减少磁盘IO
  - Cache：缓存：主要是为了减少和一些没有必要的服务进行IO的优化，本质上还是减少IO。频繁从数据库中读取同一条数据和从数据库读取一条放在Redis，下次再进行读取的时候直接走Redis：减少数据库压力。
  - Pool：池化：重复利用。线程池，对象池，连接池，缓存池等
  - Sharding：分治；单机搞不定就分片；如分库分表
  - Sticky：粘性：处理某件事的所有线程在同一个CPU核心上处理，将相同IP的访问路由到同一个主机……
  - Balance | TradeOff：trade-off翻译过来大致是折中的意思，也就是说系统设计通常牵扯的点比较多，有的设计方案这个方面比较好，但是又有其他缺点，没有十全十美的方案，只是在特定的上下文，特定的约束条件下，权衡选取比较合适的方案。但是一旦这个上下文或约束条件随着业务变化，基础设施变化等等，原来的折中的方案可能也就不合适了。于是就需要重新架构。
    * 常见的trade-off
      > 缓存：以空间换取时间，牺牲内存来加快读取速度，但同时也带来一致性维护问题
      > 数据库三范式：以时间换取空间，数据库的范式设计，有些表仅仅有主键，但是业务查询经常需要带上姓名等其他字段，这个时候就得在展示层去根据用户id再去获取用户姓名去组装数据，在持久层保持了一致性，但是对于展示层来说得额外再去关联表或查询姓名，牺牲了时间。
      > CAP：比如nosql大多是选择以AP为主，牺牲C
      > 微服务：将单体架构拆分为微服务，则在部署成本上可能比单体架构要多一些，但是带来的是服务的拆分隔离之后的相对稳定性和可维护性，但是同时也可能带来诸多一致性问题。
      > 高级语言vs汇编语言：高级语言比汇编语言更容易让人掌握，但是最后还是要转为机器懂的0和1，相比汇编是牺牲了性能，但是带来的是可维护性。
      > bean vs map：java bean比map的好处是里头的属性类型确定，不像map是个黑盒，每次用数据都得根据key去换取，然后强转，无形之中就给编码带来很多坑，提醒了易错性，但是map的好处是通用；bean就是相对不如map那么万能，但是由于每个属性确定，用的时候直接调用getter去获取，也不用类型强转，有多少属性也很明了，提升了编程的可靠性，但是坏处就是不通用。
  - QPS：Queries Per Second
  - TPS：Transactions Per Second
  - RT：Response Time
  - PV：Page View
  - UV：Unique View
  - 并发数：
  - 线程数：
2、服务拆分
  - 按照流程拆分
  - 按照业务拆分
  - 按照功能拆分
3、分布式AKF拆分原则
  - X轴：完成高可用：主备
    * 直接水平复制应用进程来扩展系统
    * 每个备机都是全量数据
    * 基于主备模型可实现主从的读写分离
    * 这个模型所能做的性能优化
  - Y轴：完成高性能
    * 将功能拆分出来扩展系统。
    * 业务拆分，即高内聚
  - Z轴：完成高扩展
    * 基于用户信息扩展系统。
    * 压力比较大的做分治处理(Sharding)
4、环境搭建
    - 负载均衡搭建
      * 地域负载均衡：DNS
        $ DNS的解析过程：正向和反向
      * 硬件负载均衡：F5：集群之间的负载均衡
      * 软件负载均衡：LVS & Nginx：主机之间的负载均衡
    - 缓存搭建
      * Redis分布式集群
      * NTP分布式集群
    - 数据库
      * MySQL主从、高可用、读写分离、分库分表
    - 其它
      * Docker & K8S
5、分布式锁
  - 单机锁
    * Synchronized
      $ wait/notify
    * ReentrantLock
      $ lock/unlock
  - 分布式锁
    * 单机锁 + TCP/IP协议栈 = 分布式锁
    * 总线协议 + 数据管程 = 单机锁
    * 当多个进程在同一个系统中，用分布式锁控制多个进程对资源的访问，解决跨JVM互斥机制来控制资源访问
    * 场景：高并发，大流量场景
  - 分布式锁的实现
    * 基于MySQL实现
    * 基于Redis实现
      $ 基于Redisson对分布式锁的实现
        1. 加锁机制：根据Hash节点选择一个客户端执行lua脚本
        2. 锁互斥机制：再来一个客户端执行同样的lua脚本会提示已经存在锁，然后进入循环一直尝试加锁
        3. 可重入机制：已经拿到锁，就可以直接进入锁的执行代码，不用重复申请锁
        4. WatchDog自动延期机制
        5. 释放锁机制：重入几次，释放几次
    * 基于ZooKeeper实现
      $ 比Redis稳
    * 基于Etcd实现