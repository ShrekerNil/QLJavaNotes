## 问题总结08 ~ 微服务
1. 什么是SOA架构? 单点→分布式→SOA→微服务
    - 服务: 将共同的相关的业务逻辑进行拆分, 进而形成一个独立的项目进行部署. 可以理解为接口.
    - SOA: 基于分布式架构演变而来, 是一个面相服务的架构, 俗称服务化, 可以理解为面相业务逻辑层, 将相关的逻辑进行抽取, 提供给其他的服务进行调用
    - 服务于服务之间进行通信采用RPC调用, 如HTTPClient, SpringCloud, Dubbo, grpc, 但是底层都是基于Netty和Socket开发
    - 概念
      * SOA: 面向于服务的架构
      * SOAP: 简单对象协议Http+XML的混合物
2. SOA特点
    - 基于SOAP或者ESB(消息总线)实现, 底层使用Http或者Https+重量级XML进行通信
    - WebService: Http+XML(SOAP)
3. SOA架构的缺点
    - 依赖于中心化的服务发现机制: 
    - 采用SOAP协议(HTTP+XML): 数据冗余, 占用宽带
    - 服务管理混乱, 缺少服务管理和治理, 设施不完善
4. 微服务架构产生的原因
    - 微服务架构师基于SOA架构演变而来的
    - 即因为SOA架构的缺点, 才出现的微服务
5. 什么是微服务架构?
    - 微服务架构师基于SOA架构演变而来的, 粒度比SOA架构更加精细, 让专业的人做专业的事, 目的是提高效率
    - 每个服务之间是互不影响, 每个服务独立部署
    - 微服务架构更加体现轻量级, 采用restful风格提供API服务: HTTP+JSON, 更加轻巧, 更加适合于互联网公司敏捷开发快速迭代产品
      * 敏捷开发: 活动之类的单独开发, 独立部署, 不影响正常服务
6. 微服务架构与SOA架构的区别.
    - 微服务架构基于 SOA架构 演变过来，继承 SOA架构的优点，在微服务架构中去除 SOA 架构中的 ESB 消息总线，采用 http+json（restful）进行传输
    - 微服务架构比 SOA 架构粒度会更加精细，让专业的人去做专业的事情（专注），目的提高效率，每个服务于服务之间互不影响，微服务架构中，每个服务必须独立部署，微服务架构更加轻巧，轻量级。
    - SOA 架构中可能数据库存储会发生共享，微服务强调独每个服务都是单独数据库，保证每个服务于服务之间互不影响。
    - 项目体现特征微服务架构比 SOA 架构更加适合与互联网公司敏捷开发、快速迭代版本，因为粒度非常精细。
7. 什么是服务治理?
    - 在传统rpc远程调用中，服务与服务依赖关系，管理比较复杂，所以需要使用服务治理，管理服务与服务之间依赖关系，可以实现服务调用、负载均衡、容错等，实现服务发现与注册。
    - 微服务 的核心是服务治理, 而服务治理的核心在于**注册中心**, 我们使用注册中心来管理服务与服务之间的依赖关系.
8. SpringCloud支持哪些注册中心?
    - Eureka
    - Consul
    - ZooKeeper
9. Eureka高可用如何实现
    - Eureka主备来实现
    - Eureka节点相互注册, 形成一组相互注册的注册中心, 从而实现数据的相互同步, 进而实现高可用
10. 服务的注册发现原理
    - 服务提供者在启动的时候, 把自己的地址和端口注册到注册中心
    - 服务的消费者在启动的时候去注册中心获取想要的服务地址列表
    - 消费者在获取到服务列表以后就会进行本地的负载均衡, 进行服务的远程调用
11. Eureka的自我保护机制
    - 默认情况下,EurekaClient会定时向EurekaServer端发送心跳，如果EurekaServer在一定时间内没有收到EurekaClient发送的心跳，便会把该实例从注册服务列表中剔除（默认是90秒）,但是在短时间内丢失大量的实例心跳，这时候EurekaServer会开启自我保护机制，Eureka不会踢出该服务。
    - 当**最后一分钟收到的心跳数**小于**心跳阈值**的时候，触发保护机制
    - 该保护机制的目的是避免网络连接故障的时候, EurekaServer错误的将EurekaClient从服务 列表中剔除
    - 为了不影响开发测试，在开发测试阶段，我们可以把自我保护模式关闭
      * eureka.server.enable-self-preservation: false
12. Ribbon本地负载均衡是怎么实现的?
    - 当服务根据服务别名从注册中心获取(DiscoveryClient)到要调用服务的集群列表的时候就会使用到本地负载均衡
    - 简单的算法: 请求数量 % 服务器数量, 得到要调用的服务下标
13. 本地负载均衡Ribbon和服务器端负载均衡Nginx有什么区别
    - 本地负载均衡(如Ribbon)适合在微服务RPC中使用, 如Dubbo, SpringCloud等
    - 服务器端负载均衡适合服务器端, 如Tomcat, Jetty等
14. SpringCloud支持哪些远程调用工具?
    - RestTemplate
      * restTemplate.getForObject(strServiceUrl, String.class)
    - Feign
      * 声明式Http调用工具, 采用接口+注解实现, 易读性比较好.
      * 消费者接口(interface)上添加注解: @FeignClient(name="服务提供者名称")
      * 接口方法上添加注解:@RequestMapping("当前接口访问地址"), 控制层代码不变
      * 启动类上添加@EnableFeignClients, 开启Feign的权限
15. 什么是网关?
    - 网关是具有两个以上的网络接口, 可以连接两个以上不同网段的设备（路由器、交换机）, 负责不同网域之间的封包转递 (IP Forwarding), 这个网关是一个泛称, 只要能连接两个以上不同网络并转换期通信协议的设备都可以称为网关.
    - 拦截请求实现安全/过滤的需求.
    - 可以理解网络中的网关为国家的海关, 保证系统安全的
16. 哪些框架可以实现网关?
    - SpringCloud: 针对生产者消费者的注册中心
    - Zuul(Java实现), 微服务专用, 相对于Nginx来说, Zuul更加灵活, 使用Java配置编写更加方便高效
    - Nginx(C语言实现): 针对服务器
17. 既然Nginx可以实现网关, 为什么还需要Zuul?
18. 网关和Nginx的区别在哪?
19. 如何搭建网关?
    - 基于Nginx搭建
      * 即基于Nginx的反向代理实现, 不同的url转发到不同的服务器
    - 基于Spring Zuul搭建
      * 客户端请求 → DNS域名解析 → LVS+KeppLive → Nginx(主备) → Zuul网关(集群,反向代理) → Web服务集群
    - LVS是四层负载均衡转发器,基于IP+Port可以管理集群请求
20. 微服务网关平台的设计思想
21. 微服务网关的作用/网关的应用场景
    - 路由转发
    - 反向代理
    - 负载均衡
    - 安全控制: 黑白名单(Header的Refer)
    - 权限控制
    - 限流
    - 监控
22. 网关与过滤器的区别
    - 网关拦截整个微服务的所有请求, 而过滤器只拦截打到当前服务器的请求
23. 网关的分类
    - 内网网关
    - 外网网关
24. Nginx与Zuul的区别
    - 相同点
      * 都可以实现反向代理/负载均衡/过滤请求, 实现网关的功能
    - 不同点
      * 性能: Nginx使用C语言编写, Zuul使用Java编写, 相对来说Nginx的性能更高
      * 负载均衡的实现: Zuul采用Ribbon+Eureka实现, 而Nginx采用算法插件实现
      * 灵活性: Nginx可以加载一些第三方插件, 也可以整合Lua脚本, 而Zuul就写死在服务器上了
      * Nginx做拦截过滤相对来说比较困难, 但是Zuul能轻松胜任
    - 总结
      * Nginx适合服务器端网关, Zuul适合微服务网关
      * 一般建议使用Nginx+Zuul来实现, Nginx做反向代理, Zuul实现为微服务的拦截过滤
      * 微服务中的网关一般都使用熟悉的语言进行开发
25. Zuul网关的拦截参数
26. 接口在什么背景下产生的?
    - 在SOA和微服务架构的背景下产生的, 目的是解耦, 可以理解为在RPC调用中产生的.
27. 接口如何分类?
    - 开放接口: 业务外部调用的接口, 如与其他公司进行合作, 有的使用专线网络
    - 内部接口: 对于后台服务系统一般局域网访问
22. 如果让你设计一套项目的接口, 你会如何设计?
    - 接口权限: 参考**接口如何分类**
    - 幂等性
    - 安全: https/网关实现黑白名单
    - 防止篡改数据: 验签
    - 跨平台: Restful风格(http+json)
    - 根据项目的请求考虑高并发, 服务的保护
    - 统一API管理: API Swagger
23. 如何统一管理微服务中的API文档?
    - Zuul + Swagger
    - Nginx + Swagger
24. Dubbo的产生背景
    - 网站架构流程
      * 传统架构: SSH/SSM
      * 分布式架构: 以项目模块进行划分
      * SOA架构: 面相服务的架构
      * 微服务架构: 粒度更加精细的面相服务的架构
    - Dubbo是在SOA架构的架构下产生的, 
      * RPC调用, 服务于服务之间调用的核心是: TCP + 二进制传输, 即 IP + 端口 即可实现访问
25. 传统的RPC远程调用有什么缺点?
    - 传统的远程调用技术: Socket/Netty/HttpClient
    - 缺少服务治理: 服务比较多的情况下, URL地址管理变得非常复杂
26. 为什么使用Dubbo?
27. 为什么要对服务实现治理?
    - 服务比较多的情况下, URL地址管理变得非常混乱
    - 服务治理的核心是注册中心
    - 实现服务治理之后即可以解决服务之间的依赖关系, 可实现负载均衡, 注册与发现, 容错等 
28. 什么是Dubbo分布式服务治理框架?
    - 一款分会服务框架
    - 高性能和透明化的RPC远程调用框架
    - SOA服务治理方案
29. Dubbo支持哪些注册中心?
    - ZooKeeper
    - Redis
    - Multicast
    - Simple
30. Dubbo分布式服务治理框架的优缺点?
    - 优点
      * 透明化的RPC调用: 像调用本地方法一样调用远程方法, 配置简单, 没有API侵入(使用Dubbo自动以协议进行调用)
      * 软负载均衡和容错: 可在内网替代Nginx/LVS等硬件负载均衡器
      * 服务注册中心自动注册&配置管理: 不需要写死生产者地址, 注册中基于接口名自动查询生产者信息, 使用zk等分布式协调服务作为服务注册中心, 可以将绝大部分项目配置移入zk集群
      * 服务接口监控与治理: Dubbo-admin和Dubbo-monitor提供了完善的服务接口管理和监控的功能, 针对不同应用的不同接口, 可以进行多版本/多协议/多注册中心进行管理
    - 缺点
      * 只支持Java语言调用
31. Dubbo底层架构原理
    - 四个角色
      * Provider
      * Consumer
      * Register
      * Monitor
    - 流程
      * 注册
          - 当生产者启动的时候, 将当前服务接口类的全限定名作为key, 以服务的生产者的实际调用地址以临时的方式注册到注册中心
          - ZK的每个服务的key都是服务提供者类的全限定名, 下面有两个目录节点, 一个consumers和providers, 分别存放服务的消费者和提供者的信息
          - 在ZK上服务的节点是持久的, 节点下面的是临时节点
      * 消费
          - 消费者启动的时候向注册中心订阅服务, 当订阅的服务产生变化的时候, ZK就会通过ZKClient回调的方式通知订阅者,即消费者.
      * RPC
          - 当消费者需要调用接口的时候就会根据从注册中心获取到的地址进行RPC操作
          - 本地采用软负载均衡, 即本地负载均衡
32. SpringCloud和Dubbo有什么区别?
    - 相同点
      * 二者都数据RPC远程调用框架
    - 不同点
      * SpringCloud的周边设施比较完善, 一般称为全家桶
33. Dubbo支持哪些协议
    - Dubbo/RMI/Hessian/http/webservice/thrift等
    - 官网推荐Dubbo协议
34. 你会使用Dubbo还是SpringCloud?
    - 相同点
      * 都是RPC的框架, 都可以实现服务的治理与发现
    - 不同点
      * 软件架构: Dubbo解决方案没有SpringCloud全面, 
        - SpringCloud把在分布式和微服务中遇到的问题的解决方案都整合进来了, 
        - 而Dubbo就住实现了服务的治理. 很多解决方案都没有内置, 如: 分布式配置中心/消息总线/网关/链路追踪等
      * 版本迭代
        - SpringCloud的版本迭代速度远超Dubbo
      * 开发背景
        - Dubbo: 阿里巴巴, 国内比较流行
        - SpringCloud: Spring, 在整个世界比较流行
    - 总结
      * 如果要采用Dubbo的方案, 需要自己组装各种方案, 而如果采用SpringCloud的话, 所有都有了, 但是在实际的开发中, 还是会整合一些比较流行的框架
35. 你了解DubboX吗?
36. SpringCloud Bus消息总线
    - 在微服务架构中，通常会使用轻量级的消息代理来构建一个共用的消息主题来连接各个微服务实例，它广播的消息会被所有在注册中心的微服务实例监听和消费，也称消息总线。 
    - SpringCloud中也有对应的解决方案，SpringCloud Bus 将分布式的节点用轻量的消息代理连接起来，可以很容易搭建消息总线，配合SpringCloud config 实现微服务应用配置信息的动态更新。
    - 消息代理属于中间件。设计代理的目的就是为了能够从应用程序中传入消息，并执行一些特别的操作。开源产品很多如ActiveMQ、Kafka、RabbitMQ、RocketMQ等 
    - 目前springCloud仅支持RabbitMQ和Kafka。
    - 消息总线其实通过消息中间件主题模式，他使用广播消息的机制被所有在注册中心微服务实例进行监听和消费。以广播形式将消息推送给所有注册中心服务列表
37. 什么是SpringCloud消息驱动
    - SpringCloud Stream消息驱动可以简化开发人员对消息中间件的使用复杂度，让系统开发人员更多尽力专注与核心业务逻辑的开发。SpringCloud Stream基于SpringBoot实现，自动配置化的功能可以帮助我们快速上手学习，类似与我们之前学习的hibernate框架一样，可以不用改sql语句，也可以切换不同的数据库，SpringCloud Stream 目前只支持 rabbitMQ和kafka
    - SpringCloud Stream消息驱动整合常用MQ框架rabbitMQ和kafka，让开发人员不需要具体的知道MQ底层实现，只需要关注核心业务逻辑编写。
38. SpringCloud消息驱动Stream实现原理
    - 通过定义绑定器作为中间层，实现了应用程序与消息中间件细节之间的隔离。通过向应用程序暴露统一的Channel通过，是的应用程序不需要再考虑各种不同的消息中间件的实现。当需要升级消息中间件，或者是更换其他消息中间件产品时，我们需要做的就是更换对应的Binder绑定器而不需要修改任何应用逻辑 。
    - 底层是如何实现：Stream组件对rabbitMQ和kafka，进行封装成同一个API,开发人员只需要对接Stream即可。
    - 默认是一通道的名称创建交换机, 消费者启动的时候会随机创建一个队列名称
    - 默认创建的队列在服务关闭后就销毁了
39. SpringCloud消息驱动Stream与传统MQ的区别
40. SpringCloud消息驱动Stream的消费分组
    - 默认情况下, 每个消费者都会接收到同一个管道发送过来的所有消息
    - 所以在有些情况下, 每个消息同时只能有一个消费者进行消费, 这时候, 我们就把这些消费者分为一组
    - 消费者分组以后, 组内的消费是以轮询的方式消费的, 即每个消息同时只能有一个消费者进行消费